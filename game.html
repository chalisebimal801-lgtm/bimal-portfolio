<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>3D Car Race Game + ChatGPT + Persistent Coins</title>
<style>
body { margin:0; overflow:hidden; font-family:Arial; background:#111; }
#message { position:absolute; top:20px; left:50%; transform:translateX(-50%); color:white; font-size:24px; background:rgba(0,0,0,0.7); padding:10px 20px; border-radius:10px; display:none;}
#ui { position:absolute; top:10px; left:10px; color:white; font-size:18px; background:rgba(0,0,0,0.5); padding:10px; border-radius:10px;}
#buttons { position:absolute; top:10px; right:10px;}
button { margin-left:10px; padding:5px 10px; font-size:16px;}
#upgradeUI { position:absolute; top:60px; left:10px; color:white; background:rgba(0,0,0,0.5); padding:10px; border-radius:10px;}
#chatContainer { position:absolute; bottom:10px; right:10px; width:300px; height:400px; background:rgba(0,0,0,0.8); color:white; display:none; flex-direction:column; border-radius:10px; padding:10px; font-size:14px;}
#chatHistory { flex:1; overflow-y:auto; margin-bottom:5px;}
#chatInput { width:80%; padding:5px;}
#sendBtn { width:18%;}
#toggleChatBtn { position:absolute; bottom:420px; right:10px; padding:5px 10px; font-size:16px;}
</style>
</head>
<body>

<div id="message"></div>
<div id="ui">Level: 1 | Coins: 0 | Engine: 1 | Tires: 1</div>
<div id="buttons">
  <button id="playPauseBtn">Pause</button>
  <button id="restartBtn">Restart</button>
</div>

<div id="upgradeUI">
  <button id="upgradeEngineBtn">Upgrade Engine (5 Coins)</button>
  <button id="upgradeTiresBtn">Upgrade Tires (5 Coins)</button>
</div>

<div id="chatContainer">
  <div id="chatHistory"></div>
  <input type="text" id="chatInput" placeholder="Type message"/>
  <button id="sendBtn">Send</button>
</div>
<button id="toggleChatBtn">Chat GPT</button>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script>
// ================== Game Variables ==================
let car, aiCars=[], coins=[], level=1;
let coinsCollected=0, engineLevel=1, tireLevel=1;
let speed=0, maxSpeed=1, acceleration=0.02, friction=0.01;
let paused=false, gameOver=false;

const ui=document.getElementById("ui");
const message=document.getElementById("message");

// ================== THREE.JS Setup ==================
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer(); renderer.setSize(window.innerWidth, window.innerHeight); document.body.appendChild(renderer.domElement);
scene.add(new THREE.AmbientLight(0xffffff,0.6));
const dirLight=new THREE.DirectionalLight(0xffffff,0.8); dirLight.position.set(50,100,50); scene.add(dirLight);

const roadWidth=20;
const roadGeo=new THREE.PlaneGeometry(roadWidth,800);
const roadMat=new THREE.MeshPhongMaterial({color:0x222222});
const road=new THREE.Mesh(roadGeo,roadMat); road.rotation.x=-Math.PI/2; scene.add(road);

// Road lines
for(let z=-380; z<400; z+=20){
  const lineGeo=new THREE.PlaneGeometry(0.5,5);
  const lineMat=new THREE.MeshBasicMaterial({color:0xffffff});
  const line=new THREE.Mesh(lineGeo,lineMat); line.rotation.x=-Math.PI/2; line.position.set(0,0.02,z); scene.add(line);
}

// Finish line
const finishGeo=new THREE.PlaneGeometry(roadWidth,2);
const finishMat=new THREE.MeshBasicMaterial({color:0xffffff});
const finishLine=new THREE.Mesh(finishGeo,finishMat); finishLine.rotation.x=-Math.PI/2; finishLine.position.set(0,0.01,-390);
scene.add(finishLine);

// ================== Create Cars ==================
function createCar(color){
  const car=new THREE.Group();
  const body=new THREE.Mesh(new THREE.BoxGeometry(4,1,8), new THREE.MeshPhongMaterial({color}));
  body.position.y=1; car.add(body);
  const roof=new THREE.Mesh(new THREE.BoxGeometry(3,1,4), new THREE.MeshPhongMaterial({color:color*0.8}));
  roof.position.set(0,2,0); car.add(roof);

  const wheelGeo=new THREE.CylinderGeometry(1,1,0.5,16);
  const wheelMat=new THREE.MeshPhongMaterial({color:0x000000});
  car.wheels=[];
  function addWheel(x,z){ const w=new THREE.Mesh(wheelGeo,wheelMat); w.rotation.z=Math.PI/2; w.position.set(x,0.5,z); car.add(w); car.wheels.push(w);}
  addWheel(-1.8,3); addWheel(1.8,3); addWheel(-1.8,-3); addWheel(1.8,-3);
  return car;
}

// ================== Initialize Game ==================
function initGame(newLevel=level){
  if(car) scene.remove(car);
  aiCars.forEach(a=>scene.remove(a));
  coins.forEach(c=>scene.remove(c));

  aiCars=[]; coins=[]; speed=0; paused=false; gameOver=false;
  level = newLevel; // keep coinsCollected, engineLevel, tireLevel

  car = createCar(0xff0000); car.position.set(0,0,380); scene.add(car);

  const aiCount = 3 + level;
  for(let i=0;i<aiCount;i++){
    const ai = createCar(0x0000ff);
    ai.position.set((i-aiCount/2)*5,0,380-Math.random()*20);
    ai.speed = 0.5+Math.random()*0.3 + 0.1*level;
    aiCars.push(ai); scene.add(ai);
  }

  const coinCount = 30 + level*10;
  const coinGeo = new THREE.SphereGeometry(0.5,16,16);
  const coinMat = new THREE.MeshPhongMaterial({color:0xffff00});
  for(let i=0;i<coinCount;i++){
    const c = new THREE.Mesh(coinGeo, coinMat);
    c.position.set((Math.random()*roadWidth-10),0.5, Math.random()*760-380);
    coins.push(c); scene.add(c);
  }

  updateUI(); 
  message.style.display="none";
}
initGame();

// ================== UI ==================
function updateUI(){ ui.innerText=`Level: ${level} | Coins: ${coinsCollected} | Engine: ${engineLevel} | Tires: ${tireLevel}`;}
function showMessage(text){ message.innerText=text; message.style.display="block";}

// ================== Controls ==================
const keys={};
document.addEventListener('keydown',e=>keys[e.key]=true);
document.addEventListener('keyup',e=>keys[e.key]=false);

// ================== Collision Detection ==================
function detectCollision(a,b){
  const dx=a.position.x-b.position.x;
  const dz=a.position.z-b.position.z;
  return Math.abs(dx)<3 && Math.abs(dz)<5;
}

// ================== ChatGPT Real-time ==================
const chatDiv=document.getElementById('chatHistory');
const chatContainer=document.getElementById('chatContainer');
const chatInput=document.getElementById('chatInput');
const toggleBtn=document.getElementById('toggleChatBtn');
const sendBtn=document.getElementById('sendBtn');
toggleBtn.onclick=()=>{ chatContainer.style.display=chatContainer.style.display==='none'?'flex':'none'; }

async function sendMessage(message){
  if(message.trim()==='') return;
  const p=document.createElement('p'); p.innerText='Player: '+message; chatDiv.appendChild(p); chatDiv.scrollTop = chatDiv.scrollHeight;

  try{
    const response = await fetch('http://localhost:3000/chat',{
      method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({message})
    });
    const data = await response.json();
    const aiP=document.createElement('p'); aiP.innerText='AI: '+data.reply; chatDiv.appendChild(aiP); chatDiv.scrollTop = chatDiv.scrollHeight;
  }catch(err){
    const errP=document.createElement('p'); errP.innerText='AI: Error connecting'; chatDiv.appendChild(errP); chatDiv.scrollTop = chatDiv.scrollHeight;
  }
}

sendBtn.onclick=()=>{ sendMessage(chatInput.value); chatInput.value=''; }
chatInput.addEventListener('keydown',e=>{ if(e.key==='Enter') sendMessage(chatInput.value) && (chatInput.value=''); });

// ================== Upgrades ==================
document.getElementById("upgradeEngineBtn").onclick=()=>{
  if(coinsCollected>=5){ coinsCollected-=5; engineLevel++; updateUI(); alert("Engine Upgraded!"); }
  else alert("Not enough coins!");
};
document.getElementById("upgradeTiresBtn").onclick=()=>{
  if(coinsCollected>=5){ coinsCollected-=5; tireLevel++; updateUI(); alert("Tires Upgraded!"); }
  else alert("Not enough coins!");
};

// ================== Game Loop ==================
function gameLoop(){
  requestAnimationFrame(gameLoop);
  if(gameOver || paused) return;

  // Movement
  if(keys['ArrowUp']) speed=Math.min(speed+acceleration*engineLevel,maxSpeed*engineLevel);
  if(keys['ArrowDown']) speed=Math.max(speed-acceleration,maxSpeed*-0.5);
  if(!keys['ArrowUp']&&!keys['ArrowDown']){
    if(speed>0) speed=Math.max(speed-friction*tireLevel,0);
    if(speed<0) speed=Math.min(speed+friction*tireLevel,0);
  }
  if(keys['ArrowLeft']) car.rotation.y+=0.05*tireLevel;
  if(keys['ArrowRight']) car.rotation.y-=0.05*tireLevel;

  car.position.x-=Math.sin(car.rotation.y)*speed;
  car.position.z-=Math.cos(car.rotation.y)*speed;
  car.wheels.forEach(w=>w.rotation.x-=speed*0.2);

  // Keep car on road
  if(car.position.x<-roadWidth/2+2) car.position.x=-roadWidth/2+2;
  if(car.position.x>roadWidth/2-2) car.position.x=roadWidth/2-2;

  // AI cars
  aiCars.forEach(ai=>{
    ai.position.z-=ai.speed; ai.wheels.forEach(w=>w.rotation.x-=ai.speed*0.2);
    if(detectCollision(car,ai)) speed=-speed*0.5;
  });

  // Coins
  for(let i=coins.length-1;i>=0;i--){
    if(coins[i].position.distanceTo(car.position)<1){ scene.remove(coins[i]); coins.splice(i,1); coinsCollected++; updateUI(); }
  }

  // Camera
  camera.position.lerp(new THREE.Vector3(car.position.x,car.position.y+8,car.position.z+15),0.1);
  camera.lookAt(car.position);

  // Win/Lose
  const allAIFinished=aiCars.some(ai=>ai.position.z<=-390);
  if(car.position.z<=-390){
    gameOver=true; showMessage("ðŸ† You Win! Level "+level+" Completed");
    setTimeout(()=>{ showMessage(""); initGame(level+1); requestAnimationFrame(gameLoop); }, 2000);
  } else if(allAIFinished){ gameOver=true; showMessage("ðŸ’€ You Lose! Upgrade or Retry"); }

  renderer.render(scene,camera);
}
requestAnimationFrame(gameLoop);

// ================== Buttons ==================
const playPauseBtn=document.getElementById("playPauseBtn");
playPauseBtn.onclick=()=>{ paused=!paused; playPauseBtn.innerText=paused?"Play":"Pause"; if(!paused) requestAnimationFrame(gameLoop); }
document.getElementById("restartBtn").onclick=()=>{ initGame(level); requestAnimationFrame(gameLoop); }

window.addEventListener('resize',()=>{ camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight); });

</script>
</body>
</html>
